// Implement Trie
struct Trie {
	bool check; // Custom for each problem, Set<int> for max index or int for value, ...
        Trie* next[26];
        Trie(): check(false) {
        	for (int i=0; i<26; ++i) next[i] = NULL;
        }
	// Using recursive to avoid memleak
	~Trie {
		for (int i=0; i<26; ++i) {
			if(next[i]) delete next[i];
		}
	}
};
    
    void insert(Trie* a, string word) {
        Trie* t = a;
        for (auto c:word) {
            if (!t->next[c-'a']) {
                Trie* b = new Trie();
                t->next[c-'a'] = b;
            }
            t = t->next[c-'a'];
        }
        t->check = true;
    }
    
    bool search(Trie* a, string word) {
        Trie* t = a;
        for (auto c:word) {
            if (!t->next[c-'a']) return false;
            t = t->next[c-'a'];
        }
        return t->check;
    }
    
    bool isPre(Trie* a, string word) {
        Trie* t = a;
        for (auto c:word) {
            if (!t->next[c-'a']) return false;
            t = t->next[c-'a'];
        }
        return true;
    }


// Split string
	vector<string> ret;
	stringstream ss(p);
	string tok;
	while(getline(ss, tok, '*')) {
		if (tok != "") ret.push_back(tok);
	}

//Direction
vector<vector<int>> dir{{-1,0},{1,0},{0,-1},{0,1}};

// Binary search
	while (l < r-1) {
		int m = (r+l)/2;
		if (check(a, k, m)) r = m;
		else l = m;
	}
	return r;
	//r can't be 0 so use instead
        while (l < r) {
            int m = (r+l)/2;
            if (check(map, k, m)) r = m;
            else l = m+1;
	}
	return l;

// Min, maxheap
struct classcomp {
  bool operator() (const int& lhs, const int& rhs) const
  {return lhs>rhs;}
};

set<int, classcomp> maxheap;
set<int> minheap;

static bool fncomp (pair<double,int>& lhs, pair<double,int>& rhs) {
	return lhs.first > rhs.first;
}
bool(*fn_pt)(pair<double,int> &, pair<double,int> &) = fncomp;
multiset<pair<double,int>, bool(*)(pair<double,int> &, pair<double,int> &)> pq(fn_pt);
	
// Building from 2 side
	vector<int> s(n,-1);
	if (a==1 && b==1 && c==1 && n==1) {
		cout<<"1";
		return;
	}
	if ( (c+a-c+b-c > n) || ((a==b) && (a==c) && (a == 1))) {
		cout<<"IMPOSSIBLE";
		return;
	}
	int l = a-c, r= b-c;
	int temp = n-l;
	for (int i=0; i<l; ++i) s[i] = temp++;
	temp = n-r;
	for (int i=0; i<r; ++i) s[n-1-i] = temp++;

	if (c == 1) {
		if (l == 0) s[0] = n;
		else if (r == 0) s[n-1] = n;
		else s[l] = n;
	}
	else {
		s[l] = n;
		s[n-1-r] = n;
		for (int i=0; i<c-2;++i) {
			s[l+1+i] = n;
		}
	}
	for (int i=0; i<n; ++i) {
		if (s[i] == -1) s[i] = 1;
		cout<<s[i]<<" ";
	}

	
// Toys
	bool fncomp (pair<ll,ll> lhs, pair<ll,ll> rhs) {return lhs.second > rhs.second;}
	void Solve(vector<vector<ll>>& a) {
		ll sum = 0, need = 0;
		ll n = a.size();
		ll ret = 0;
		for (int i=0; i<n; ++i) sum+=a[i][0];
		ll cur = sum, maxTime = sum;
		//auto *fn_pt = fncomp;
		bool(*fn_pt)(pair<ll,ll>, pair<ll,ll>) = fncomp;
		multiset<pair<ll,ll>, bool(*)(pair<ll,ll>, pair<ll,ll>)> store(fn_pt);
		
		for (int i=0; i<n; ++i) {
			cur += a[i][0];
			store.insert({i,a[i][0] + a[i][1]});
			while (!store.empty()) {
				pair<ll,ll> temp = *store.begin();
				if (temp.second <= sum) break;
				sum -= a[temp.first][0];
				cur -= 2*a[temp.first][0];
				store.erase(store.begin());
				need++;
			}
			if (cur > maxTime) {
				ret = need;
				maxTime = cur;
			}
		}
		if (!store.empty()) ret = need;
		cout<<ret<<" ";
		if (!store.empty()) cout<<"INDEFINITELY";
		else cout<<maxTime;
		return;
	}

// Disjoint-Set structure with path compression by rank
	struct UnionFind {
		vector<int> par;
		vector<int> rank;
		vector<int> deg; //mark if visit, no need
	 
		UnionFind(int n) {
			par.resize(n);
			for (int i = 0; i < n; ++i) {
				par[i] = i;
			}
			rank.resize(n,0);
			deg.resize(n,0);
		}
		virtual ~UnionFind() {}
	 
		int find(int x) { return (par[x] == x) ? x : par[x] = find(par[x]); }
	 
		void merge(int x, int y) {
			deg[x] += 1;
			deg[y] += 1;
	 
			int xset = find(x);
			int yset = find(y);
			if (xset == yset)   return;
	 
			if (rank[xset] > rank[yset]) {
				par[yset] = xset;
			} else {
				par[xset] = yset;
				if (rank[xset]==rank[yset]) {
					rank[yset] += 1;
				}
			}
		}
	 
		void reset() {
			for (int i = 0; i < par.size(); ++i) {
				par[i] = i;
			}
			fill(rank.begin(), rank.end(), 0);
			fill(deg.begin(), deg.end(), 0);
		}
	};

	// To check how many component in disjoint-set
	UnionFind u(n);
        for (auto i:arr) {
            u.merge(i[0], i[1]);
        }
        int ans = 0;
        for (int i = 0; i < n; i++)
            if (u.par[i] == i) ans++; // ans is number of component;
        return ans;

// Matrix prefix sum
        int m = mat.size(), n = mat[0].size();
        vector<vector<int>> rangeSum(m+1, vector<int>(n+1, 0));
        
        for(int i=0; i<m; i++) {
            for(int j=0; j<n; j++) {
                rangeSum[i+1][j+1] = rangeSum[i+1][j] + rangeSum[i][j+1] - rangeSum[i][j] + mat[i][j];
            }
        }
	// Sum rectangle bottom, up, right, left. https://leetcode.com/problems/matrix-block-sum/discuss/477041/Java-Prefix-sum-with-Picture-explain-Clean-code-O(m*n)
	sum = rangeSum[bottom][right] - rangeSum[up][right] - rangeSum[bottom][left] + rangeSum[up][left];
	
	// Solution 2
	 for (int r = 1; r <= m; r++) {
            for (int c = 1; c <= n; c++) {
                sum[r][c] = mat[r - 1][c - 1] + sum[r - 1][c] + sum[r][c - 1] - sum[r - 1][c - 1];
            }
        }
	// Sum
	for (int r = 0; r < m; r++) {
            for (int c = 0; c < n; c++) {
                int r1 = Math.max(0, r - K), c1 = Math.max(0, c - K);
                int r2 = Math.min(m - 1, r + K), c2 = Math.min(n - 1, c + K);
                r1++; c1++; r2++; c2++; // Since `sum` start with 1 so we need to increase r1, c1, r2, c2 by 1
                ans[r][c] = sum[r2][c2] - sum[r2][c1-1] - sum[r1-1][c2] + sum[r1-1][c1-1];
            }
        }
// Abs
	|A| + |B| = max(|A+B|, |A-B|)

//Greedy take all max value
	int getMax(std::multiset<int>& sets)
	{
		int days = 0, sum = 0;
		auto iter = std::rbegin(sets);
		while (iter != std::rend(sets) && *iter - days > 0) {
			sum += *iter - days;
			iter++, days++;
		}
		return sum;
	}
	 
	int main()
	{
		int n, a;
		std::multiset<int> sets;
		std::cin >> n;
		for (int i = 0; i < n; i++) {
			std::cin >> a;
			sets.insert(a);
		}
		std::cout << getMax(sets) << std::endl;
		return 0;
	}